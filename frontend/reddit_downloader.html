<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reddit Downloader Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #ff4500 0%, #ff6b35 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #ff4500, #ff6b35);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        /* Navigation Links */
        .nav-links {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .nav-btn {
            text-decoration: none;
            font-size: 14px;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.3s;
            font-weight: 500;
        }

        .nav-btn.primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .nav-btn.secondary {
            background: linear-gradient(45deg, #6b7280, #374151);
            color: white;
        }

        .nav-btn.success {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
        }

        .nav-btn.current {
            background: linear-gradient(45deg, #ff4500, #ff6b35);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .main-content {
            padding: 30px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #333;
        }

        .url-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .url-input:focus {
            outline: none;
            border-color: #ff4500;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .option-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .option-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #ff4500;
        }

        .option-item label {
            margin: 0;
            cursor: pointer;
            font-size: 14px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 150px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff4500, #ff6b35);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 69, 0, 0.4);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e0e0e0;
        }

        .btn-secondary:hover {
            background: #e9ecef;
        }

        .progress-container {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            display: none;
            border: 2px solid #ff4500;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #e0e0e0;
            border-radius: 6px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #ff4500, #ff6b35);
            transition: width 0.3s;
            width: 0%;
        }

        .result-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #ff4500;
        }

        .result-card.success {
            border-left-color: #48bb78;
            background: #c6f6d5;
        }

        .result-card.error {
            border-left-color: #e53e3e;
            background: #fed7d7;
        }

        .result-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .result-meta {
            color: #666;
            margin-bottom: 15px;
        }

        .download-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .copy-btn {
            background: #48bb78;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .copy-btn:hover {
            background: #38a169;
        }

        .error {
            background: #fed7d7;
            color: #c53030;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #e53e3e;
        }

        .note {
            background: #bee3f8;
            color: #2b6cb0;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #3182ce;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #ff4500;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #ff4500;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .stat-number {
            font-size: 1.8em;
            font-weight: 600;
            color: #ff4500;
        }

        .stat-label {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }

        @media (max-width: 600px) {
            .btn-group {
                flex-direction: column;
            }
            
            .nav-links {
                flex-direction: column;
                align-items: center;
            }
            
            .options-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Tab Styles */
        .tab-btn {
            padding: 10px 20px;
            border: none;
            background: #f8f9fa;
            color: #666;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            font-weight: 500;
            transition: all 0.3s;
        }

        .tab-btn.active {
            background: linear-gradient(45deg, #ff4500, #ff6b35);
            color: white;
        }

        .tab-btn:hover:not(.active) {
            background: #e9ecef;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .bulk-result {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #ff4500;
        }

        .bulk-result.success {
            border-left-color: #48bb78;
            background: #c6f6d5;
        }

        .bulk-result.error {
            border-left-color: #e53e3e;
            background: #fed7d7;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔴 Reddit Downloader Pro</h1>
            <p>Enhanced Reddit content extraction with comments, metadata, and multiple export formats!</p>
            
            <!-- Navigation Links -->
            <div class="nav-links">
                <a href="/" class="nav-btn primary">🎬 Full YouTube App</a>
                <a href="debug_frontend.html" class="nav-btn secondary">🔧 Debug Tools</a>
                <a href="simple_extractor.html" class="nav-btn success">🔗 Simple URL Extractor</a>
                <a href="reddit_downloader.html" class="nav-btn current">🔴 Reddit Downloader (Current)</a>
            </div>
        </div>

        <div class="main-content">
            <div class="note">
                <strong>🔴 Reddit Content Extractor:</strong> Download Reddit posts with comments, metadata, author info, and images. Supports multiple export formats including Markdown, JSON, and ZIP archives.
            </div>

            <!-- Reddit API Configuration Section -->
            <div class="api-config-section" style="background: linear-gradient(135deg, #1a472a, #2d5a3d); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #48cc66;">
                <h3 style="margin-top: 0; color: #48cc66;">🔑 Reddit API Configuration (Optional)</h3>
                <p style="margin-bottom: 15px; color: #e1e8ed;">
                    For higher rate limits and better reliability, configure Reddit API credentials.
                    <a href="https://www.reddit.com/prefs/apps" target="_blank" style="color: #48cc66;">Get API keys here</a>
                </p>
                
                <div class="api-inputs" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; color: #48cc66;">Client ID:</label>
                        <input type="text" id="redditClientId" placeholder="Your Reddit app client ID" 
                               style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #48cc66; background: #0f1419; color: #e1e8ed;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; color: #48cc66;">Client Secret:</label>
                        <input type="password" id="redditClientSecret" placeholder="Your Reddit app client secret" 
                               style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #48cc66; background: #0f1419; color: #e1e8ed;">
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button onclick="saveRedditApiConfig()" style="background: #48cc66; color: #0f1419; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">
                        💾 Save Credentials
                    </button>
                    <button onclick="testRedditApiConfig()" style="background: #ff6b35; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">
                        🧪 Test Connection
                    </button>
                    <span id="apiConfigStatus" style="color: #48cc66;"></span>
                </div>
            </div>

            <div class="input-group">
                <label for="redditInput">🔗 Enter Reddit URL (post, comment, or subreddit):</label>
                <input type="url" id="redditInput" class="url-input" placeholder="https://www.reddit.com/r/subreddit/comments/..." />
                <small style="color: #666; margin-top: 5px; display: block;">
                    💡 Supports: Posts, Comments, User profiles, Subreddits
                </small>
            </div>

            <!-- Tabs for Single/Bulk -->
            <div style="display: flex; gap: 10px; margin: 20px 0; border-bottom: 2px solid #e0e0e0;">
                <button class="tab-btn active" onclick="switchRedditTab('single')">🔗 Single Reddit URL</button>
                <button class="tab-btn" onclick="switchRedditTab('bulk')">📋 Bulk Reddit URLs</button>
            </div>

            <!-- Single Reddit Tab -->
            <div id="singleRedditTab" class="tab-content active">
                <div class="input-group">
                    <label for="redditInput">🔗 Enter Reddit URL (post, comment, or subreddit):</label>
                    <input type="url" id="redditInput" class="url-input" placeholder="https://www.reddit.com/r/subreddit/comments/..." />
                    <small style="color: #666; margin-top: 5px; display: block;">
                        💡 Supports: Posts, Comments, User profiles, Subreddits
                    </small>
                </div>
            </div>

            <!-- Bulk Reddit Tab -->
            <div id="bulkRedditTab" class="tab-content" style="display: none;">
                <div class="input-group">
                    <label for="bulkRedditInput">📋 Enter Multiple Reddit URLs (one per line):</label>
                    <textarea id="bulkRedditInput" class="url-input" rows="8" placeholder="https://www.reddit.com/r/subreddit/comments/example1/&#10;https://www.reddit.com/r/subreddit/comments/example2/&#10;https://www.reddit.com/r/subreddit/comments/example3/"></textarea>
                    <small style="color: #666; margin-top: 5px; display: block;">
                        💡 Enter one Reddit URL per line for bulk processing
                    </small>
                </div>

                <div class="bulk-options" style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <h4 style="margin-top: 0;">🔧 Bulk Processing Options:</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="bulkContinueOnError" checked>
                            <label for="bulkContinueOnError">Continue on errors</label>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="bulkAutoDownload" checked>
                            <label for="bulkAutoDownload">Auto-download ZIP</label>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="bulkShowProgress" checked>
                            <label for="bulkShowProgress">Show progress details</label>
                        </div>
                    </div>
                </div>

                <div id="bulkStats" style="display: none;" class="stats-container">
                    <div class="stat-item">
                        <div class="stat-number" id="bulkProcessed">0</div>
                        <div class="stat-label">Processed</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="bulkSuccessful">0</div>
                        <div class="stat-label">Successful</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="bulkFailed">0</div>
                        <div class="stat-label">Failed</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="bulkTotalComments">0</div>
                        <div class="stat-label">Total Comments</div>
                    </div>
                </div>

                <div id="bulkRedditResults" style="margin-top: 20px;"></div>
            </div>

            <div class="input-group">
                <label>📋 Download Options:</label>
                <div class="options-grid">
                    <div class="option-item">
                        <input type="checkbox" id="includeComments" checked>
                        <label for="includeComments">💬 Include Comments</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="includeMetadata" checked>
                        <label for="includeMetadata">📊 Include Metadata</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="includeImages" checked>
                        <label for="includeImages">🖼️ Include Images</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="includeAuthor" checked>
                        <label for="includeAuthor">👤 Include Author Info</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="includeTimestamps" checked>
                        <label for="includeTimestamps">⏰ Include Timestamps</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="includeScores" checked>
                        <label for="includeScores">⭐ Include Scores</label>
                    </div>
                </div>
            </div>

            <div class="input-group">
                <label for="maxComments">📊 Max Comments to Download:</label>
                <select id="maxComments" class="url-input" style="width: auto; min-width: 200px;">
                    <option value="25">25 comments</option>
                    <option value="50" selected>50 comments</option>
                    <option value="100">100 comments</option>
                    <option value="250">250 comments</option>
                    <option value="500">500 comments</option>
                    <option value="-1">All comments</option>
                </select>
            </div>

            <div id="redditButtons" class="btn-group">
                <button class="btn btn-primary" onclick="processRedditContent()" id="mainProcessBtn">🔴 Download Reddit Content</button>
                <button class="btn btn-secondary" onclick="clearResults()">🗑️ Clear Results</button>
                <button class="btn btn-secondary" onclick="loadSampleUrl()">🧪 Load Sample</button>
                <button class="btn btn-secondary" onclick="downloadAllBulkRedditAsZip()" id="bulkDownloadBtn" style="display: none;">📦 Download All as ZIP</button>
            </div>

            <div class="progress-container" id="progressContainer">
                <h4>🔄 Processing Reddit content...</h4>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p id="progressText">Initializing...</p>
            </div>

            <div id="results"></div>
        </div>
    </div>

    <script>
        // Enhanced Reddit Content Downloader with Improved Rate Limiting
        class RedditDownloader {
            constructor() {
                this.cache = new Map();
                this.apiAttempts = 0;
                this.maxRetries = 3;
                this.rateLimitDelay = 1000; // 1 second between requests
                this.lastRequestTime = 0;
                
                // Reddit rate limits: 60 requests per minute for unauthenticated
                this.requestsPerMinute = 60;
                this.requestQueue = [];
                this.processingQueue = false;
            }

            async downloadContent(url, options) {
                try {
                    this.updateProgress(10, 'Validating Reddit URL...');
                    
                    if (!this.isValidRedditUrl(url)) {
                        throw new Error('Please enter a valid Reddit URL (e.g., https://www.reddit.com/r/subreddit/comments/...)');
                    }

                    this.updateProgress(25, 'Fetching Reddit data...');
                    const rawData = await this.fetchRedditData(url, options);
                    
                    this.updateProgress(50, 'Processing content...');
                    const processedData = await this.processRedditData(rawData, options);
                    
                    this.updateProgress(75, 'Generating downloads...');
                    const result = await this.formatResult(processedData, url, options);
                    
                    this.updateProgress(100, 'Complete!');
                    return result;

                } catch (error) {
                    console.error('Reddit download error:', error);
                    throw new Error(`Failed to download Reddit content: ${error.message}`);
                }
            }

            isValidRedditUrl(url) {
                try {
                    const urlObj = new URL(url);
                    const isReddit = urlObj.hostname.includes('reddit.com');
                    const hasComments = url.includes('/comments/');
                    
                    // Log URL validation for debugging
                    console.log('🔍 URL Validation:', { 
                        url, 
                        hostname: urlObj.hostname, 
                        isReddit, 
                        hasComments,
                        pathname: urlObj.pathname 
                    });
                    
                    return isReddit && hasComments;
                } catch (error) {
                    console.error('URL validation error:', error);
                    return false;
                }
            }

            async fetchRedditData(url, options) {
                // Clean URL - remove query parameters that might interfere
                const cleanUrl = this.cleanRedditUrl(url);
                console.log('🧹 Cleaned URL:', cleanUrl);
                
                // Rate limiting
                await this.enforceRateLimit();
                
                const strategies = [
                    () => this.fetchWithRedditAPI(cleanUrl, options), // NEW: Official Reddit API
                    () => this.fetchWithJsonApi(cleanUrl, options),
                    () => this.fetchWithOldReddit(cleanUrl, options),
                    () => this.fetchWithCorsProxy(cleanUrl, options),
                    () => this.fetchWithPushshift(cleanUrl, options)
                ];

                let lastError = null;
                
                for (let i = 0; i < strategies.length; i++) {
                    try {
                        this.updateProgress(25 + (i * 8), `Trying fetch strategy ${i + 1}...`);
                        const data = await strategies[i]();
                        if (data && this.isValidRedditData(data)) {
                            console.log(`✅ Strategy ${i + 1} succeeded`);
                            return data;
                        }
                    } catch (error) {
                        console.warn(`❌ Strategy ${i + 1} failed:`, error.message);
                        lastError = error;
                        
                        // Wait before trying next strategy
                        if (i < strategies.length - 1) {
                            await this.sleep(500);
                        }
                    }
                }
                
                throw new Error(`All fetch strategies failed. Last error: ${lastError?.message || 'Unknown error'}`);
            }

            cleanRedditUrl(url) {
                try {
                    const urlObj = new URL(url);
                    // Remove query parameters that interfere with .json API
                    const cleanUrl = `${urlObj.protocol}//${urlObj.hostname}${urlObj.pathname}`;
                    return cleanUrl.replace(/\/$/, ''); // Remove trailing slash
                } catch (error) {
                    console.warn('URL cleaning failed, using original:', error);
                    return url.replace(/\/$/, '');
                }
            }

            async enforceRateLimit() {
                const now = Date.now();
                const timeSinceLastRequest = now - this.lastRequestTime;
                
                if (timeSinceLastRequest < this.rateLimitDelay) {
                    const waitTime = this.rateLimitDelay - timeSinceLastRequest;
                    console.log(`⏰ Rate limiting: waiting ${waitTime}ms`);
                    await this.sleep(waitTime);
                }
                
                this.lastRequestTime = Date.now();
            }

            async sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            isValidRedditData(data) {
                return data && 
                       Array.isArray(data) && 
                       data.length > 0 && 
                       data[0]?.data?.children?.length > 0;
            }

            async fetchWithRedditAPI(url, options) {
                // NEW: Official Reddit API with OAuth (if credentials provided)
                const redditApiConfig = this.getRedditApiConfig();
                
                if (!redditApiConfig.clientId) {
                    throw new Error('Reddit API credentials not configured');
                }

                try {
                    console.log('🔑 Using Reddit OAuth API');
                    
                    // Extract post ID from URL for API call
                    const postId = this.extractPostId(url);
                    if (!postId) throw new Error('Could not extract post ID');

                    // Get OAuth token if not cached
                    if (!this.oauthToken || this.isTokenExpired()) {
                        await this.getRedditOAuthToken(redditApiConfig);
                    }

                    // Fetch post data
                    const postResponse = await fetch(`https://oauth.reddit.com/comments/${postId}`, {
                        headers: {
                            'Authorization': `Bearer ${this.oauthToken}`,
                            'User-Agent': redditApiConfig.userAgent
                        }
                    });

                    if (!postResponse.ok) {
                        if (postResponse.status === 401) {
                            // Token expired, refresh and retry
                            await this.getRedditOAuthToken(redditApiConfig);
                            return this.fetchWithRedditAPI(url, options);
                        }
                        throw new Error(`Reddit API error: ${postResponse.status}`);
                    }

                    return await postResponse.json();
                } catch (error) {
                    throw new Error(`Reddit OAuth API failed: ${error.message}`);
                }
            }

            getRedditApiConfig() {
                // This will be populated with user-provided credentials
                return {
                    clientId: localStorage.getItem('reddit_client_id') || '',
                    clientSecret: localStorage.getItem('reddit_client_secret') || '',
                    userAgent: 'RedditDownloader/2.0 by YourUsername',
                    redirectUri: 'http://localhost:8000'
                };
            }

            async getRedditOAuthToken(config) {
                try {
                    const auth = btoa(`${config.clientId}:${config.clientSecret}`);
                    
                    const response = await fetch('https://www.reddit.com/api/v1/access_token', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Basic ${auth}`,
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'User-Agent': config.userAgent
                        },
                        body: 'grant_type=client_credentials'
                    });

                    if (!response.ok) {
                        throw new Error(`OAuth token request failed: ${response.status}`);
                    }

                    const tokenData = await response.json();
                    this.oauthToken = tokenData.access_token;
                    this.tokenExpiry = Date.now() + (tokenData.expires_in * 1000);
                    
                    console.log('✅ Reddit OAuth token obtained');
                } catch (error) {
                    throw new Error(`OAuth authentication failed: ${error.message}`);
                }
            }

            isTokenExpired() {
                return !this.tokenExpiry || Date.now() >= this.tokenExpiry;
            }

            async fetchWithJsonApi(url, options) {
                let jsonUrl = url.replace(/\/$/, '') + '.json';
                
                // Enhanced query parameters for better Reddit API compatibility
                const params = new URLSearchParams();
                params.append('raw_json', '1');
                params.append('api_type', 'json');
                
                if (options.maxComments > 0 && options.maxComments !== 999999) {
                    params.append('limit', Math.min(options.maxComments, 500).toString());
                }
                
                if (params.toString()) {
                    jsonUrl += (jsonUrl.includes('?') ? '&' : '?') + params.toString();
                }

                console.log('🔗 Fetching from Reddit JSON API:', jsonUrl);
                
                const response = await fetch(jsonUrl, {
                    method: 'GET',
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (compatible; RedditDownloader/2.0; Educational/Research)',
                        'Accept': 'application/json, text/plain, */*',
                        'Accept-Language': 'en-US,en;q=0.9',
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache'
                    },
                    cache: 'no-cache'
                });

                if (!response.ok) {
                    if (response.status === 429) {
                        throw new Error('Rate limited by Reddit. Please wait a moment and try again.');
                    } else if (response.status === 403) {
                        throw new Error('Access forbidden. This may be a private subreddit or the post was deleted.');
                    } else if (response.status === 404) {
                        throw new Error('Reddit post not found. Please check the URL.');
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                
                if (!data || (Array.isArray(data) && data.length === 0)) {
                    throw new Error('No data received from Reddit API');
                }

                return data;
            }

            async fetchWithOldReddit(url, options) {
                const oldRedditUrl = url.replace('www.reddit.com', 'old.reddit.com')
                                      .replace('reddit.com', 'old.reddit.com')
                                      .replace(/\/$/, '') + '.json';
                
                console.log('🔗 Fetching from Old Reddit:', oldRedditUrl);
                
                const response = await fetch(oldRedditUrl, {
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (compatible; RedditDownloader/2.0)',
                        'Accept': 'application/json',
                        'Referer': 'https://old.reddit.com/'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Old Reddit API failed: ${response.status} ${response.statusText}`);
                }

                return await response.json();
            }

            async fetchWithCorsProxy(url, options) {
                // Enhanced CORS proxy with multiple fallbacks
                const proxies = [
                    'https://api.allorigins.win/raw?url=',
                    'https://corsproxy.io/?',
                    'https://cors-anywhere.herokuapp.com/'
                ];
                
                const jsonUrl = url + '.json';
                
                for (const proxy of proxies) {
                    try {
                        const proxyUrl = proxy + encodeURIComponent(jsonUrl);
                        console.log('🔗 Trying CORS proxy:', proxy);
                        
                        const response = await fetch(proxyUrl, {
                            headers: {
                                'User-Agent': 'Mozilla/5.0 (compatible; RedditDownloader/2.0)',
                                'Accept': 'application/json'
                            }
                        });
                        
                        if (!response.ok) continue;
                        
                        const data = await response.json();
                        if (this.isValidRedditData(data)) {
                            return data;
                        }
                    } catch (error) {
                        console.warn(`CORS proxy ${proxy} failed:`, error.message);
                    }
                }
                
                throw new Error('All CORS proxies failed');
            }

            async fetchWithPushshift(url, options) {
                // Fallback for deleted/archived content using Pushshift API
                try {
                    const postId = this.extractPostId(url);
                    if (!postId) throw new Error('Could not extract post ID');
                    
                    const pushshiftUrl = `https://api.pushshift.io/reddit/submission/search/?ids=${postId}`;
                    console.log('🔗 Trying Pushshift API for archived content');
                    
                    const response = await fetch(pushshiftUrl);
                    if (!response.ok) throw new Error('Pushshift API failed');
                    
                    const data = await response.json();
                    if (data.data && data.data.length > 0) {
                        // Convert Pushshift format to Reddit format
                        return this.convertPushshiftToRedditFormat(data.data[0]);
                    }
                    
                    throw new Error('No data from Pushshift');
                } catch (error) {
                    throw new Error(`Pushshift fallback failed: ${error.message}`);
                }
            }

            extractPostId(url) {
                const match = url.match(/\/comments\/([a-zA-Z0-9]+)/);
                return match ? match[1] : null;
            }

            convertPushshiftToRedditFormat(pushshiftData) {
                return [{
                    data: {
                        children: [{
                            data: {
                                ...pushshiftData,
                                selftext: pushshiftData.selftext || '[Deleted]',
                                title: pushshiftData.title || '[Deleted Post]'
                            }
                        }]
                    }
                }];
            }

            async processRedditData(data, options) {
                const result = {
                    post: null,
                    comments: [],
                    metadata: {},
                    images: [],
                    stats: { totalComments: 0, totalScore: 0 }
                };

                try {
                    if (Array.isArray(data) && data.length > 0) {
                        // Process post data
                        const postListing = data[0];
                        if (postListing?.data?.children?.[0]) {
                            const postData = postListing.data.children[0].data;
                            result.post = this.extractPostData(postData, options);
                        } else {
                            throw new Error('Invalid post data structure');
                        }

                        // Process comments
                        if (data.length > 1 && options.includeComments) {
                            const commentsListing = data[1];
                            if (commentsListing?.data?.children) {
                                result.comments = this.extractComments(commentsListing.data.children, options);
                                result.stats.totalComments = result.comments.length;
                                result.stats.totalScore = result.comments.reduce((sum, c) => sum + (c.score || 0), 0);
                            }
                        }

                        // Extract metadata
                        if (options.includeMetadata) {
                            result.metadata = this.extractMetadata(result.post, result.comments);
                        }

                        // Extract images
                        if (options.includeImages && result.post) {
                            result.images = this.extractImages(result.post);
                        }
                    } else {
                        throw new Error('No valid data structure received from Reddit');
                    }
                } catch (error) {
                    console.error('Error processing Reddit data:', error);
                    throw new Error(`Data processing failed: ${error.message}`);
                }

                return result;
            }

            extractPostData(postData, options) {
                const post = {
                    id: postData.id,
                    title: postData.title || '[No Title]',
                    selftext: postData.selftext || '',
                    url: postData.url,
                    permalink: `https://reddit.com${postData.permalink}`,
                    subreddit: postData.subreddit || 'unknown',
                    domain: postData.domain || 'reddit.com'
                };

                if (options.includeAuthor) {
                    post.author = postData.author || '[deleted]';
                    post.author_flair_text = postData.author_flair_text;
                }

                if (options.includeTimestamps) {
                    post.created_utc = postData.created_utc;
                    post.created = postData.created_utc ? new Date(postData.created_utc * 1000).toISOString() : null;
                }

                if (options.includeScores) {
                    post.score = postData.score || 0;
                    post.upvote_ratio = postData.upvote_ratio || 0;
                    post.num_comments = postData.num_comments || 0;
                }

                return post;
            }

            extractComments(commentChildren, options, level = 0) {
                const comments = [];

                for (const child of commentChildren) {
                    if (child.kind === 't1' && child.data) {
                        // Skip deleted/removed comments unless they have replies
                        if (!child.data.body && !child.data.replies) continue;
                        
                        const comment = {
                            id: child.data.id,
                            body: child.data.body || '[deleted]',
                            level: level
                        };

                        if (options.includeAuthor) {
                            comment.author = child.data.author || '[deleted]';
                            comment.author_flair_text = child.data.author_flair_text;
                        }

                        if (options.includeTimestamps) {
                            comment.created_utc = child.data.created_utc;
                            comment.created = child.data.created_utc ? new Date(child.data.created_utc * 1000).toISOString() : null;
                        }

                        if (options.includeScores) {
                            comment.score = child.data.score || 0;
                            comment.controversiality = child.data.controversiality || 0;
                        }

                        comments.push(comment);

                        // Process replies recursively with depth limit
                        if (child.data.replies && 
                            child.data.replies.data && 
                            child.data.replies.data.children && 
                            level < 10) { // Prevent infinite recursion
                            const replies = this.extractComments(child.data.replies.data.children, options, level + 1);
                            comments.push(...replies);
                        }
                    }
                }

                return comments;
            }

            extractMetadata(post, comments) {
                return {
                    extracted_at: new Date().toISOString(),
                    post_id: post?.id,
                    subreddit: post?.subreddit,
                    total_comments: comments.length,
                    comment_levels: comments.length > 0 ? Math.max(...comments.map(c => c.level), 0) : 0,
                    extraction_version: '2.1',
                    api_rate_limited: false,
                    extraction_method: 'reddit_json_api'
                };
            }

            extractImages(post) {
                const images = [];
                
                // Check for direct image links
                if (post.url && this.isImageUrl(post.url)) {
                    images.push({
                        url: post.url,
                        type: 'post_image',
                        source: 'direct'
                    });
                }

                // Check for Reddit gallery
                if (post.url && post.url.includes('reddit.com/gallery/')) {
                    images.push({
                        url: post.url,
                        type: 'reddit_gallery',
                        source: 'reddit'
                    });
                }

                return images;
            }

            isImageUrl(url) {
                const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg', '.bmp'];
                const imageDomains = ['i.imgur.com', 'i.redd.it', 'preview.redd.it'];
                
                return imageExtensions.some(ext => url.toLowerCase().includes(ext)) ||
                       imageDomains.some(domain => url.includes(domain));
            }

            async formatResult(processedData, originalUrl, options) {
                return {
                    ...processedData,
                    original_url: originalUrl,
                    options_used: options,
                    success: true,
                    extracted_at: new Date().toISOString()
                };
            }

            updateProgress(percent, text) {
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                
                if (progressFill) progressFill.style.width = percent + '%';
                if (progressText) progressText.textContent = text;
            }
        }

        // Global downloader instance
        const redditDownloader = new RedditDownloader();
        let currentRedditData = null;

        // Bulk processing variables
        let allBulkRedditData = [];
        let bulkProcessingStats = {
            processed: 0,
            successful: 0,
            failed: 0,
            totalComments: 0
        };

        // Enhanced Reddit-specific title templates
        const redditTitleTemplates = {
            single: 'reddit_{subreddit}_{title}_{date}',
            bulk: 'reddit_bulk_{count}_posts_{date}',
            custom: 'reddit_{title}_{date}'
        };

        function generateRedditFilename(data, type = 'single', extension = 'md', index = null) {
            const template = redditTitleTemplates[type] || redditTitleTemplates.custom;
            const date = new Date().toISOString().split('T')[0];
            const time = new Date().toISOString().split('T')[1].slice(0, 8).replace(/:/g, '-');
            
            let filename = template;
            
            // Replace template variables
            const replacements = {
                '{title}': sanitizeRedditFilename(data.post?.title || data.title || 'untitled'),
                '{subreddit}': sanitizeRedditFilename(data.post?.subreddit || data.subreddit || 'unknown'),
                '{author}': sanitizeRedditFilename(data.post?.author || data.author || 'unknown'),
                '{date}': date,
                '{time}': time,
                '{datetime}': `${date}_${time}`,
                '{id}': data.post?.id || data.id || 'unknown',
                '{score}': data.post?.score || data.score || '0',
                '{comments}': data.comments?.length || '0',
                '{count}': data.count || allBulkRedditData.length || '0',
                '{index}': index !== null ? index + 1 : '1'
            };
            
            // Apply replacements
            Object.entries(replacements).forEach(([key, value]) => {
                filename = filename.replace(new RegExp(key.replace(/[{}]/g, '\\$&'), 'g'), value);
            });
            
            // Clean up any remaining template variables
            filename = filename.replace(/\{[^}]*\}/g, '');
            
            // Clean up multiple separators
            filename = filename.replace(/[-_\s]+/g, '_').replace(/^[-_]+|[-_]+$/g, '');
            
            return `${filename}.${extension}`;
        }

        function sanitizeRedditFilename(str) {
            if (!str) return 'untitled';
            return str.toString()
                     .replace(/[<>:"/\\|?*]/g, '')
                     .replace(/\s+/g, '_')
                     .substring(0, 50)
                     .trim();
        }

        // Tab Management
        function switchRedditTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
            });
            
            const activeTab = document.getElementById(tabName + 'RedditTab');
            if (activeTab) {
                activeTab.classList.add('active');
                activeTab.style.display = 'block';
            }
            
            // Update button text and functionality
            const mainBtn = document.getElementById('mainProcessBtn');
            const bulkBtn = document.getElementById('bulkDownloadBtn');
            
            if (tabName === 'bulk') {
                mainBtn.innerHTML = '🔴 Process Bulk Reddit URLs';
                bulkBtn.style.display = allBulkRedditData.length > 0 ? 'inline-block' : 'none';
            } else {
                mainBtn.innerHTML = '🔴 Download Reddit Content';
                bulkBtn.style.display = 'none';
            }
        }

        // Main processing function that handles both single and bulk
        async function processRedditContent() {
            const activeTab = document.querySelector('.tab-content.active').id;
            
            if (activeTab === 'bulkRedditTab') {
                await processBulkRedditUrls();
            } else {
                await downloadRedditContent();
            }
        }

        // Original single Reddit download function
        async function downloadRedditContent() {
            const url = document.getElementById('redditInput').value.trim();
            const resultsDiv = document.getElementById('results');
            const progressContainer = document.getElementById('progressContainer');

            if (!url) {
                showError('Please enter a Reddit URL');
                return;
            }

            // Collect options
            const options = {
                includeComments: document.getElementById('includeComments').checked,
                includeMetadata: document.getElementById('includeMetadata').checked,
                includeImages: document.getElementById('includeImages').checked,
                includeAuthor: document.getElementById('includeAuthor').checked,
                includeTimestamps: document.getElementById('includeTimestamps').checked,
                includeScores: document.getElementById('includeScores').checked,
                maxComments: parseInt(document.getElementById('maxComments').value)
            };

            // Show progress
            progressContainer.style.display = 'block';
            resultsDiv.innerHTML = '';

            try {
                const result = await redditDownloader.downloadContent(url, options);
                displayResult(result);
                currentRedditData = result;

                // Hide progress after delay
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 1500);

            } catch (error) {
                showError(error.message);
                progressContainer.style.display = 'none';
            }
        }

        // New bulk Reddit processing function
        async function processBulkRedditUrls() {
            const bulkInput = document.getElementById('bulkRedditInput').value.trim();
            const resultsDiv = document.getElementById('bulkRedditResults');
            const progressContainer = document.getElementById('progressContainer');
            const bulkStats = document.getElementById('bulkStats');

            if (!bulkInput) {
                showError('Please enter Reddit URLs for bulk processing');
                return;
            }

            // Parse URLs
            const urls = bulkInput.split('\n')
                                  .map(url => url.trim())
                                  .filter(url => url.length > 0);

            if (urls.length === 0) {
                showError('No valid URLs found');
                return;
            }

            // Reset stats
            bulkProcessingStats = {
                processed: 0,
                successful: 0,
                failed: 0,
                totalComments: 0
            };
            allBulkRedditData = [];

            // Get options
            const options = {
                includeComments: document.getElementById('includeComments').checked,
                includeMetadata: document.getElementById('includeMetadata').checked,
                includeImages: document.getElementById('includeImages').checked,
                includeAuthor: document.getElementById('includeAuthor').checked,
                includeTimestamps: document.getElementById('includeTimestamps').checked,
                includeScores: document.getElementById('includeScores').checked,
                maxComments: parseInt(document.getElementById('maxComments').value)
            };

            const bulkOptions = {
                continueOnError: document.getElementById('bulkContinueOnError').checked,
                autoDownload: document.getElementById('bulkAutoDownload').checked,
                showProgress: document.getElementById('bulkShowProgress').checked
            };

            // Show progress and stats
            progressContainer.style.display = 'block';
            bulkStats.style.display = 'grid';
            resultsDiv.innerHTML = '';
            document.getElementById('bulkDownloadBtn').style.display = 'none';

            // Process each URL
            for (let i = 0; i < urls.length; i++) {
                const url = urls[i];
                
                try {
                    redditDownloader.updateProgress(
                        Math.round((i / urls.length) * 100), 
                        `Processing ${i + 1}/${urls.length}: ${url.substring(0, 50)}...`
                    );

                    const result = await redditDownloader.downloadContent(url, options);
                    result.bulkIndex = i;
                    result.bulkUrl = url;
                    
                    allBulkRedditData.push(result);
                    bulkProcessingStats.successful++;
                    bulkProcessingStats.totalComments += result.comments?.length || 0;
                    
                    if (bulkOptions.showProgress) {
                        displayBulkResult(result, 'success', i + 1);
                    }

                } catch (error) {
                    bulkProcessingStats.failed++;
                    
                    if (bulkOptions.showProgress) {
                        displayBulkResult({
                            original_url: url,
                            error: error.message,
                            bulkIndex: i,
                            bulkUrl: url
                        }, 'error', i + 1);
                    }

                    if (!bulkOptions.continueOnError) {
                        break;
                    }
                }

                bulkProcessingStats.processed++;
                updateBulkStats();
                
                // Rate limiting - wait between requests
                if (i < urls.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            // Final update
            redditDownloader.updateProgress(100, `Completed: ${bulkProcessingStats.successful} successful, ${bulkProcessingStats.failed} failed`);
            
            // Show download button if we have successful results
            if (bulkProcessingStats.successful > 0) {
                document.getElementById('bulkDownloadBtn').style.display = 'inline-block';
                
                // Auto-download if option is enabled
                if (bulkOptions.autoDownload) {
                    setTimeout(() => downloadAllBulkRedditAsZip(), 2000);
                }
            }

            // Hide progress after delay
            setTimeout(() => {
                progressContainer.style.display = 'none';
            }, 3000);
        }

        function displayBulkResult(result, status, index) {
            const resultsDiv = document.getElementById('bulkRedditResults');
            const resultDiv = document.createElement('div');
            resultDiv.className = `bulk-result ${status}`;
            
            if (status === 'success') {
                const title = result.post?.title || 'Unknown Title';
                const subreddit = result.post?.subreddit || 'unknown';
                const commentsCount = result.comments?.length || 0;
                
                resultDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div style="flex: 1;">
                            <strong>✅ ${index}. ${title}</strong><br>
                            <small>📍 r/${subreddit} | 💬 ${commentsCount} comments | 🔗 <a href="${result.original_url}" target="_blank">View Post</a></small>
                        </div>
                        <div style="display: flex; gap: 5px;">
                            <button class="copy-btn" onclick="copyBulkRedditItem(${result.bulkIndex})">📋</button>
                            <button class="copy-btn" onclick="downloadBulkRedditItem(${result.bulkIndex})">💾</button>
                        </div>
                    </div>
                `;
            } else {
                resultDiv.innerHTML = `
                    <div>
                        <strong>❌ ${index}. Failed to process</strong><br>
                        <small>🔗 ${result.bulkUrl}</small><br>
                        <small style="color: #c53030;">Error: ${result.error}</small>
                    </div>
                `;
            }
            
            resultsDiv.appendChild(resultDiv);
        }

        function updateBulkStats() {
            document.getElementById('bulkProcessed').textContent = bulkProcessingStats.processed;
            document.getElementById('bulkSuccessful').textContent = bulkProcessingStats.successful;
            document.getElementById('bulkFailed').textContent = bulkProcessingStats.failed;
            document.getElementById('bulkTotalComments').textContent = bulkProcessingStats.totalComments;
        }

        function copyBulkRedditItem(index) {
            const result = allBulkRedditData[index];
            if (result) {
                const markdown = generateMarkdown(result);
                navigator.clipboard.writeText(markdown).then(() => {
                    alert('Reddit content copied to clipboard!');
                }).catch(() => {
                    alert('Failed to copy to clipboard');
                });
            }
        }

        function downloadBulkRedditItem(index) {
            const result = allBulkRedditData[index];
            if (result) {
                const markdown = generateMarkdown(result);
                const filename = generateRedditFilename(result, 'single', 'md', index);
                downloadFile(markdown, filename, 'text/markdown');
                alert(`Downloaded ${filename}!`);
            }
        }

        async function downloadAllBulkRedditAsZip() {
            if (allBulkRedditData.length === 0) {
                alert('No Reddit data to download!');
                return;
            }
            
            if (typeof JSZip === 'undefined') {
                alert('ZIP functionality requires JSZip library');
                return;
            }
            
            const zip = new JSZip();
            
            // Add individual files
            allBulkRedditData.forEach((result, index) => {
                const markdown = generateMarkdown(result);
                const filename = generateRedditFilename(result, 'single', 'md', index);
                zip.file(filename, markdown);
                
                // Also add JSON data
                const jsonFilename = generateRedditFilename(result, 'single', 'json', index);
                zip.file(jsonFilename, JSON.stringify(result, null, 2));
            });
            
            // Add combined markdown file
            const combinedMarkdown = allBulkRedditData.map(result => generateMarkdown(result)).join('\n\n========================================\n\n');
            const combinedFilename = generateRedditFilename({
                title: 'all_reddit_posts_combined',
                subreddit: 'bulk',
                count: allBulkRedditData.length
            }, 'bulk', 'md');
            zip.file(combinedFilename, combinedMarkdown);
            
            // Add summary JSON
            const summaryData = {
                exportedAt: new Date().toISOString(),
                totalPosts: allBulkRedditData.length,
                totalComments: bulkProcessingStats.totalComments,
                stats: bulkProcessingStats,
                posts: allBulkRedditData
            };
            const summaryFilename = generateRedditFilename({
                title: 'bulk_reddit_summary',
                subreddit: 'bulk',
                count: allBulkRedditData.length
            }, 'bulk', 'json');
            zip.file(summaryFilename, JSON.stringify(summaryData, null, 2));
            
            // Generate and download ZIP
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const zipFilename = generateRedditFilename({
                title: 'reddit_bulk_download',
                subreddit: 'archive',
                count: allBulkRedditData.length
            }, 'bulk', 'zip');
            
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = zipFilename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert(`Downloaded ${allBulkRedditData.length} Reddit posts as ${zipFilename}!`);
        }

        function displayResult(data) {
            const resultsDiv = document.getElementById('results');
            
            const postTitle = data.post?.title || 'Reddit Content';
            const cleanTitle = postTitle.replace(/[^a-zA-Z0-9\s]/g, '').substring(0, 50);
            
            resultsDiv.innerHTML = `
                <div class="result-card success">
                    <div class="result-title">🔴 Reddit Content Successfully Extracted</div>
                    <div class="result-meta">
                        <strong>📝 Title:</strong> ${data.post?.title || 'N/A'}<br>
                        <strong>📍 Subreddit:</strong> r/${data.post?.subreddit || 'unknown'}<br>
                        <strong>🔗 URL:</strong> <a href="${data.original_url}" target="_blank">${data.original_url}</a>
                    </div>
                    
                    <div class="stats-container">
                        <div class="stat-item">
                            <div class="stat-number">${data.comments.length}</div>
                            <div class="stat-label">Comments</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number">${data.images.length}</div>
                            <div class="stat-label">Images</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number">${data.post?.score || 0}</div>
                            <div class="stat-label">Post Score</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number">${data.stats?.totalScore || 0}</div>
                            <div class="stat-label">Comments Score</div>
                        </div>
                    </div>
                    
                    <div class="download-actions">
                        <button class="btn btn-primary" onclick="downloadMarkdown('${cleanTitle}')">📝 Download Markdown</button>
                        <button class="btn btn-secondary" onclick="downloadJSON('${cleanTitle}')">📄 Download JSON</button>
                        <button class="btn btn-secondary" onclick="downloadZip('${cleanTitle}')">📦 Download ZIP</button>
                        <button class="copy-btn" onclick="copyToClipboard()">📋 Copy Markdown</button>
                    </div>
                </div>
            `;
        }

        function showError(message) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `
                <div class="error">
                    <strong>❌ Error:</strong> ${message}
                    <br><br>
                    <strong>Troubleshooting:</strong>
                    <ul style="margin-top: 10px; padding-left: 20px;">
                        <li>Make sure the Reddit URL is valid and accessible</li>
                        <li>Try with a different Reddit post</li>
                        <li>Check if the post/comments are not deleted</li>
                        <li>Some private subreddits may not be accessible</li>
                    </ul>
                </div>
            `;
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            document.getElementById('redditInput').value = '';
            document.getElementById('progressContainer').style.display = 'none';
            currentRedditData = null;
        }

        function loadSampleUrl() {
            const sampleUrls = [
                'https://www.reddit.com/r/programming/comments/1234567/sample_programming_post/',
                'https://www.reddit.com/r/explainlikeimfive/comments/7654321/eli5_how_reddit_works/',
                'https://www.reddit.com/r/technology/comments/9876543/new_technology_discussion/'
            ];
            
            const randomUrl = sampleUrls[Math.floor(Math.random() * sampleUrls.length)];
            document.getElementById('redditInput').value = randomUrl;
        }

        // Download functions
        function generateMarkdown(data) {
            let markdown = `# ${data.post?.title || 'Reddit Content'}\n\n`;
            
            if (data.post) {
                markdown += `**Subreddit:** r/${data.post.subreddit}\n`;
                if (data.post.author) markdown += `**Author:** u/${data.post.author}\n`;
                if (data.post.score !== undefined) markdown += `**Score:** ${data.post.score}\n`;
                if (data.post.created) markdown += `**Posted:** ${new Date(data.post.created).toLocaleString()}\n`;
                markdown += `**URL:** ${data.post.permalink}\n\n`;
                
                if (data.post.selftext) {
                    markdown += `## Post Content\n\n${data.post.selftext}\n\n`;
                }
            }
            
            if (data.comments.length > 0) {
                markdown += `## Comments (${data.comments.length})\n\n`;
                data.comments.forEach((comment, index) => {
                    const indent = '  '.repeat(comment.level);
                    const author = comment.author ? `**${comment.author}**` : 'Unknown';
                    const score = comment.score !== undefined ? ` (${comment.score} points)` : '';
                    const timestamp = comment.created ? ` - ${new Date(comment.created).toLocaleString()}` : '';
                    
                    markdown += `${indent}${author}${score}${timestamp}:\n`;
                    markdown += `${indent}${comment.body}\n\n`;
                });
            }
            
            return markdown;
        }

        function downloadMarkdown(filename) {
            if (!currentRedditData) return;
            
            const markdown = generateMarkdown(currentRedditData);
            const smartFilename = generateRedditFilename(currentRedditData, 'single', 'md');
            downloadFile(markdown, smartFilename, 'text/markdown');
            alert(`Downloaded ${smartFilename}!`);
        }

        function downloadJSON(filename) {
            if (!currentRedditData) return;
            
            const smartFilename = generateRedditFilename(currentRedditData, 'single', 'json');
            downloadFile(JSON.stringify(currentRedditData, null, 2), smartFilename, 'application/json');
            alert(`Downloaded ${smartFilename}!`);
        }

        async function downloadZip(filename) {
            if (!currentRedditData || typeof JSZip === 'undefined') {
                alert('ZIP functionality requires JSZip library');
                return;
            }
            
            const zip = new JSZip();
            
            // Add markdown file
            const markdownFilename = generateRedditFilename(currentRedditData, 'single', 'md');
            zip.file(markdownFilename, generateMarkdown(currentRedditData));
            
            // Add JSON file
            const jsonFilename = generateRedditFilename(currentRedditData, 'single', 'json');
            zip.file(jsonFilename, JSON.stringify(currentRedditData, null, 2));
            
            // Add images info if any
            if (currentRedditData.images.length > 0) {
                const imagesFolder = zip.folder('images');
                currentRedditData.images.forEach((img, index) => {
                    imagesFolder.file(`image_${index + 1}_info.txt`, `URL: ${img.url}\nType: ${img.type}\nSource: ${img.source}`);
                });
            }
            
            // Generate and download ZIP
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const zipFilename = generateRedditFilename(currentRedditData, 'single', 'zip');
            
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = zipFilename;
            a.click();
            URL.revokeObjectURL(url);
            alert(`Downloaded ${zipFilename}!`);
        }

        function copyToClipboard() {
            if (!currentRedditData) return;
            
            const markdown = generateMarkdown(currentRedditData);
            navigator.clipboard.writeText(markdown).then(() => {
                alert('Reddit content copied to clipboard!');
            }).catch(() => {
                alert('Failed to copy to clipboard');
            });
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Allow Enter key to trigger download
        document.getElementById('redditInput').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                downloadRedditContent();
            }
        });

        // Reddit API Configuration Functions
        function saveRedditApiConfig() {
            const clientId = document.getElementById('redditClientId').value.trim();
            const clientSecret = document.getElementById('redditClientSecret').value.trim();
            const statusElement = document.getElementById('apiConfigStatus');
            
            if (clientId && clientSecret) {
                localStorage.setItem('reddit_client_id', clientId);
                localStorage.setItem('reddit_client_secret', clientSecret);
                statusElement.textContent = '✅ Credentials saved';
                statusElement.style.color = '#48cc66';
            } else {
                statusElement.textContent = '❌ Please enter both Client ID and Secret';
                statusElement.style.color = '#ff6b35';
            }
            
            setTimeout(() => {
                statusElement.textContent = '';
            }, 3000);
        }

        async function testRedditApiConfig() {
            const statusElement = document.getElementById('apiConfigStatus');
            statusElement.textContent = '🧪 Testing connection...';
            statusElement.style.color = '#ffa500';
            
            try {
                const config = redditDownloader.getRedditApiConfig();
                if (!config.clientId || !config.clientSecret) {
                    throw new Error('Please save credentials first');
                }
                
                await redditDownloader.getRedditOAuthToken(config);
                statusElement.textContent = '✅ Connection successful!';
                statusElement.style.color = '#48cc66';
            } catch (error) {
                statusElement.textContent = `❌ Connection failed: ${error.message}`;
                statusElement.style.color = '#ff6b35';
            }
            
            setTimeout(() => {
                statusElement.textContent = '';
            }, 5000);
        }

        function debugUrl() {
            const url = document.getElementById('redditInput').value.trim();
            const resultsDiv = document.getElementById('results');
            
            if (!url) {
                alert('Please enter a URL first');
                return;
            }
            
            console.log('🔍 Starting URL debug for:', url);
            
            // Test URL validation
            const isValid = redditDownloader.isValidRedditUrl(url);
            const cleanUrl = redditDownloader.cleanRedditUrl(url);
            const postId = redditDownloader.extractPostId(url);
            
            const debugInfo = {
                original_url: url,
                is_valid: isValid,
                cleaned_url: cleanUrl,
                post_id: postId,
                api_config: redditDownloader.getRedditApiConfig(),
                has_credentials: !!localStorage.getItem('reddit_client_id')
            };
            
            console.log('🔍 URL Debug Results:', debugInfo);
            
            resultsDiv.innerHTML = `
                <div class="result-card" style="background: #1a472a; border: 1px solid #48cc66;">
                    <div class="result-title">🔍 URL Debug Results</div>
                    <div style="margin-top: 15px; font-family: monospace; font-size: 14px;">
                        <strong>Original URL:</strong> ${debugInfo.original_url}<br>
                        <strong>Valid Reddit URL:</strong> ${debugInfo.is_valid ? '✅ Yes' : '❌ No'}<br>
                        <strong>Cleaned URL:</strong> ${debugInfo.cleaned_url}<br>
                        <strong>Post ID:</strong> ${debugInfo.post_id || 'Not found'}<br>
                        <strong>API Credentials:</strong> ${debugInfo.has_credentials ? '✅ Configured' : '❌ Not configured'}<br>
                        <strong>Rate Limit Status:</strong> Ready<br>
                    </div>
                    <div style="margin-top: 15px;">
                        <button class="btn btn-primary" onclick="testRedditStrategies()">🧪 Test All Strategies</button>
                        <button class="btn btn-secondary" onclick="clearResults()">Clear</button>
                    </div>
                </div>
            `;
        }

        async function testRedditStrategies() {
            const url = document.getElementById('redditInput').value.trim();
            const resultsDiv = document.getElementById('results');
            
            if (!url) return;
            
            const cleanUrl = redditDownloader.cleanRedditUrl(url);
            const strategies = [
                { name: 'Reddit OAuth API', func: () => redditDownloader.fetchWithRedditAPI(cleanUrl, {}) },
                { name: 'Reddit JSON API', func: () => redditDownloader.fetchWithJsonApi(cleanUrl, {}) },
                { name: 'Old Reddit API', func: () => redditDownloader.fetchWithOldReddit(cleanUrl, {}) },
                { name: 'CORS Proxy', func: () => redditDownloader.fetchWithCorsProxy(cleanUrl, {}) },
                { name: 'Pushshift API', func: () => redditDownloader.fetchWithPushshift(cleanUrl, {}) }
            ];
            
            let results = '<div class="result-card" style="background: #1a472a; border: 1px solid #48cc66;">';
            results += '<div class="result-title">🧪 Strategy Test Results</div>';
            
            for (let i = 0; i < strategies.length; i++) {
                const strategy = strategies[i];
                results += `<div style="margin: 10px 0; padding: 10px; background: #0f1419; border-radius: 5px;">`;
                results += `<strong>${strategy.name}:</strong> <span id="strategy-${i}">🔄 Testing...</span></div>`;
                
                resultsDiv.innerHTML = results + '</div>';
                
                try {
                    const data = await strategy.func();
                    const success = redditDownloader.isValidRedditData(data);
                    document.getElementById(`strategy-${i}`).innerHTML = success ? '✅ Success' : '⚠️ Invalid data';
                    document.getElementById(`strategy-${i}`).style.color = success ? '#48cc66' : '#ffa500';
                } catch (error) {
                    document.getElementById(`strategy-${i}`).innerHTML = `❌ Failed: ${error.message}`;
                    document.getElementById(`strategy-${i}`).style.color = '#ff6b35';
                }
            }
        }

        // Load saved credentials on page load
        window.addEventListener('load', function() {
            const savedClientId = localStorage.getItem('reddit_client_id');
            const savedClientSecret = localStorage.getItem('reddit_client_secret');
            
            if (savedClientId) document.getElementById('redditClientId').value = savedClientId;
            if (savedClientSecret) document.getElementById('redditClientSecret').value = savedClientSecret;
            
            if (savedClientId && savedClientSecret) {
                document.getElementById('apiConfigStatus').textContent = '✅ Credentials loaded';
                document.getElementById('apiConfigStatus').style.color = '#48cc66';
            }
        });

        console.log('🔴 Reddit Downloader Pro v2.1 loaded');
    </script>
</body>
</html> 